/// Task BLoC for managing task state.
library;

import 'package:altair_core/altair_core.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:logger/logger.dart';

import 'task_event.dart';
import 'task_state.dart';

/// BLoC for managing task state and operations.
class TaskBloc extends Bloc<TaskEvent, TaskState> {
  /// Creates a task bloc.
  TaskBloc({
    required TaskRepository taskRepository,
    Logger? logger,
  })  : _taskRepository = taskRepository,
        _logger = logger ?? Logger(),
        super(const TaskInitial()) {
    on<TaskLoadRequested>(_onLoadRequested);
    on<TaskQuickCaptureRequested>(_onQuickCaptureRequested);
    on<TaskCreateRequested>(_onCreateRequested);
    on<TaskUpdateRequested>(_onUpdateRequested);
    on<TaskDeleteRequested>(_onDeleteRequested);
    on<TaskSearchRequested>(_onSearchRequested);
    on<TaskFilterByStatusRequested>(_onFilterByStatusRequested);
    on<TaskFilterByTagsRequested>(_onFilterByTagsRequested);
    on<TaskClearFiltersRequested>(_onClearFiltersRequested);
    on<TaskReorderRequested>(_onReorderRequested);
  }

  final TaskRepository _taskRepository;
  final Logger _logger;

  /// Handles loading all tasks.
  Future<void> _onLoadRequested(
    TaskLoadRequested event,
    Emitter<TaskState> emit,
  ) async {
    emit(const TaskLoading());

    try {
      final tasks = await _taskRepository.findAll();
      emit(TaskLoaded(tasks: tasks));
      _logger.i('Loaded ${tasks.length} tasks');
    } catch (e, stackTrace) {
      _logger.e('Failed to load tasks', error: e, stackTrace: stackTrace);
      emit(TaskFailure(message: e.toString()));
    }
  }

  /// Handles quick capture of a new task.
  Future<void> _onQuickCaptureRequested(
    TaskQuickCaptureRequested event,
    Emitter<TaskState> emit,
  ) async {
    try {
      final now = DateTime.now();
      final task = Task(
        id: '', // Will be generated by repository
        title: event.title,
        createdAt: now,
        updatedAt: now,
        status: TaskStatus.todo,
        priority: 3, // Default priority
      );

      final createdTask = await _taskRepository.create(task);
      _logger.i('Quick captured task: ${createdTask.id}');

      // Emit success state briefly
      emit(TaskCaptured(task: createdTask));

      // Then reload all tasks
      final tasks = await _taskRepository.findAll();
      emit(TaskLoaded(tasks: tasks));
    } catch (e, stackTrace) {
      _logger.e('Failed to quick capture task',
          error: e, stackTrace: stackTrace);
      emit(TaskFailure(message: e.toString()));
    }
  }

  /// Handles creating a new task with full details.
  Future<void> _onCreateRequested(
    TaskCreateRequested event,
    Emitter<TaskState> emit,
  ) async {
    emit(const TaskLoading());

    try {
      await _taskRepository.create(event.task);
      _logger.i('Created task: ${event.task.id}');

      final tasks = await _taskRepository.findAll();
      emit(TaskLoaded(tasks: tasks));
    } catch (e, stackTrace) {
      _logger.e('Failed to create task', error: e, stackTrace: stackTrace);
      emit(TaskFailure(message: e.toString()));
    }
  }

  /// Handles updating an existing task.
  Future<void> _onUpdateRequested(
    TaskUpdateRequested event,
    Emitter<TaskState> emit,
  ) async {
    emit(const TaskLoading());

    try {
      await _taskRepository.update(event.task);
      _logger.i('Updated task: ${event.task.id}');

      final tasks = await _taskRepository.findAll();
      emit(TaskLoaded(tasks: tasks));
    } catch (e, stackTrace) {
      _logger.e('Failed to update task', error: e, stackTrace: stackTrace);
      emit(TaskFailure(message: e.toString()));
    }
  }

  /// Handles deleting a task.
  Future<void> _onDeleteRequested(
    TaskDeleteRequested event,
    Emitter<TaskState> emit,
  ) async {
    emit(const TaskLoading());

    try {
      await _taskRepository.delete(event.taskId);
      _logger.i('Deleted task: ${event.taskId}');

      final tasks = await _taskRepository.findAll();
      emit(TaskLoaded(tasks: tasks));
    } catch (e, stackTrace) {
      _logger.e('Failed to delete task', error: e, stackTrace: stackTrace);
      emit(TaskFailure(message: e.toString()));
    }
  }

  /// Handles searching tasks.
  Future<void> _onSearchRequested(
    TaskSearchRequested event,
    Emitter<TaskState> emit,
  ) async {
    emit(const TaskLoading());

    try {
      final tasks = await _taskRepository.search(event.query);
      emit(TaskLoaded(tasks: tasks));
      _logger.i('Search returned ${tasks.length} tasks');
    } catch (e, stackTrace) {
      _logger.e('Failed to search tasks', error: e, stackTrace: stackTrace);
      emit(TaskFailure(message: e.toString()));
    }
  }

  /// Handles filtering tasks by status.
  Future<void> _onFilterByStatusRequested(
    TaskFilterByStatusRequested event,
    Emitter<TaskState> emit,
  ) async {
    emit(const TaskLoading());

    try {
      final tasks = await _taskRepository.findAll(status: event.status);
      emit(TaskLoaded(tasks: tasks, filter: event.status));
      _logger.i('Filtered ${tasks.length} tasks by status: ${event.status}');
    } catch (e, stackTrace) {
      _logger.e('Failed to filter tasks', error: e, stackTrace: stackTrace);
      emit(TaskFailure(message: e.toString()));
    }
  }

  /// Handles filtering tasks by tags.
  Future<void> _onFilterByTagsRequested(
    TaskFilterByTagsRequested event,
    Emitter<TaskState> emit,
  ) async {
    emit(const TaskLoading());

    try {
      final tasks = await _taskRepository.findAll(tags: event.tags);
      emit(TaskLoaded(tasks: tasks, tagFilter: event.tags));
      _logger.i('Filtered ${tasks.length} tasks by tags: ${event.tags}');
    } catch (e, stackTrace) {
      _logger.e('Failed to filter tasks by tags',
          error: e, stackTrace: stackTrace);
      emit(TaskFailure(message: e.toString()));
    }
  }

  /// Handles clearing all filters.
  Future<void> _onClearFiltersRequested(
    TaskClearFiltersRequested event,
    Emitter<TaskState> emit,
  ) async {
    emit(const TaskLoading());

    try {
      final tasks = await _taskRepository.findAll();
      emit(TaskLoaded(tasks: tasks));
      _logger.i('Cleared filters, showing all ${tasks.length} tasks');
    } catch (e, stackTrace) {
      _logger.e('Failed to clear filters', error: e, stackTrace: stackTrace);
      emit(TaskFailure(message: e.toString()));
    }
  }

  /// Handles reordering tasks in the list.
  void _onReorderRequested(
    TaskReorderRequested event,
    Emitter<TaskState> emit,
  ) {
    final currentState = state;
    if (currentState is! TaskLoaded) {
      return;
    }

    final tasks = List<Task>.from(currentState.tasks);

    // Adjust indices for Flutter's ReorderableListView behavior
    final oldIndex = event.oldIndex;
    final newIndex =
        event.oldIndex < event.newIndex ? event.newIndex - 1 : event.newIndex;

    // Reorder the list
    final task = tasks.removeAt(oldIndex);
    tasks.insert(newIndex, task);

    emit(TaskLoaded(tasks: tasks));
    _logger.i('Reordered task from index $oldIndex to $newIndex');
  }
}
